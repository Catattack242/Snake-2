<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Snake 2</title>
<style>
  /* Basic Reset and Body Styling */
  body {
    margin: 0; 
    padding: 0;
    background: #111; 
    color: white; 
    font-family: Arial, sans-serif; 
    display: flex; 
    flex-direction: column; 
    align-items: center;
    justify-content: flex-start;
    user-select: none;
    height: 100vh;
    height: 100dvh;
    overflow: hidden;
    position: relative;
    transition: filter 0.2s ease;
  }

  /* Container for the game and controls */
  .game-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    position: relative;
    width: 100%;
    padding: 5px 10px 20px 10px;
    box-sizing: border-box;
  }

  /* Show/hide game container */
  #gameContainer {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
  }

  /* Display for current level and score */
  #levelDisplay {
    font-size: 18px;
    color: #0ff;
    text-align: center;
    font-weight: bold;
    text-shadow: 0 0 10px #0ff;
    margin-bottom: 5px;
  }

  #scoreDisplay {
    font-size: 14px;
    color: #fff;
    text-align: center;
    margin-bottom: 5px;
  }

  /* The game canvas styling */
  canvas {
    background: #000;
    border: 2px solid #fff;
    touch-action: none;
    transition: all 2s ease;
    width: 80vw;
    height: 80vw;
    max-width: 350px;
    max-height: 350px;
  }

  /* Controls grid layout - made more compact */
  .controls {
    display: grid;
    grid-template-columns: 80px 80px 80px;
    grid-template-rows: 80px 80px 80px;
    gap: 8px;
    justify-content: center;
    margin-top: 10px;
  }

  /* Style for control buttons - smaller */
  .btn {
    width: 80px;
    height: 80px;
    font-size: 32px;
    border: 2px solid #fff;
    border-radius: 8px;
    background-color: #333;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    user-select: none;
    transition: background-color 0.1s ease;
  }

  /* Button active state */
  .btn:active {
    background-color: #555;
  }

  .btn:hover {
    background-color: #444;
  }

  /* Responsive adjustments for mobile screens */
  @media(max-width: 480px) {
    canvas {
      width: 75vw;
      height: 75vw;
      max-width: 300px;
      max-height: 300px;
    }
    .controls {
      grid-template-columns: 45px 45px 45px;
      grid-template-rows: 45px 45px 45px;
      gap: 6px;
      margin-top: 8px;
    }
    .btn {
      width: 45px;
      height: 45px;
      font-size: 18px;
    }
    #levelDisplay {
      font-size: 16px;
      margin-bottom: 3px;
    }
    #scoreDisplay {
      font-size: 12px;
      margin-bottom: 3px;
    }
    .game-wrapper {
      gap: 5px;
      padding: 3px 5px 25px 5px;
    }
  }

  /* Optimized for Galaxy S23 (393x851 dp) */
  @media(max-width: 400px) and (min-height: 800px) {
    canvas {
      width: 70vw;
      height: 70vw;
      max-width: 280px;
      max-height: 280px;
    }
    .controls {
      grid-template-columns: 42px 42px 42px;
      grid-template-rows: 42px 42px 42px;
      gap: 5px;
      margin-top: 8px;
    }
    .btn {
      width: 42px;
      height: 42px;
      font-size: 16px;
    }
    #levelDisplay {
      font-size: 15px;
      margin-bottom: 2px;
    }
    #scoreDisplay {
      font-size: 11px;
      margin-bottom: 2px;
    }
    .game-wrapper {
      gap: 3px;
      padding: 2px 3px 30px 3px;
    }
  }

  /* Overlay that appears when the snake dies and video plays */
  #deathOverlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.9);
    display: none;
    z-index: 9999;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }

  /* Container for the YouTube player inside the overlay */
  #player {
    width: 90%;
    height: 70%;
    max-width: 800px;
    max-height: 600px;
    background: #000;
    border-radius: 8px;
  }

  /* Skip button styling */
  #skipBtn {
    position: absolute;
    top: 20px;
    right: 20px;
    padding: 10px 20px;
    background: rgba(0,0,0,0.8);
    color: white;
    border: 2px solid white;
    border-radius: 5px;
    cursor: pointer;
    z-index: 10000;
    font-family: Arial, sans-serif;
    font-size: 14px;
  }

  #skipBtn:hover {
    background: rgba(255,255,255,0.2);
  }


</style>
</head>
<body>

<!-- Main container -->
<div class="game-wrapper">
  <!-- Container for the game, hidden when watching ad -->
  <div id="gameContainer">
    <!-- Display for current level -->
    <p id="levelDisplay">LEVEL 1: MICRO WORLD</p>
    <p id="scoreDisplay">Score: 0 | Size: 3</p>
    <!-- The game canvas -->
    <canvas id="game" width="640" height="640"></canvas>
    <!-- Control buttons -->
    <div class="controls">
      <button class="btn" data-dir="up" style="grid-column: 2; grid-row: 1;">⬆️</button>
      <button class="btn" data-dir="left" style="grid-column: 1; grid-row: 2;">⬅️</button>
      <button class="btn" data-dir="down" style="grid-column: 2; grid-row: 3;">⬇️</button>
      <button class="btn" data-dir="right" style="grid-column: 3; grid-row: 2;">➡️</button>
    </div>
  </div>
  <!-- Overlay for death video -->
  <div id="deathOverlay">
    <div id="player"></div>
    <button id="skipBtn" style="display: none;">Skip Ad</button>
  </div>
</div>

<!-- Load the YouTube iframe API -->
<script src="https://www.youtube.com/iframe_api"></script>

<script>
(function() {
  // --------- Setup variables ---------
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const levelDisplay = document.getElementById('levelDisplay');
  const scoreDisplay = document.getElementById('scoreDisplay');
  const overlay = document.getElementById('deathOverlay');
  const gameContainer = document.getElementById('gameContainer');
  const skipBtn = document.getElementById('skipBtn');

  // --------- Array of death videos ---------
  const deathVideos = [
    'G-T3qKl6y-c', // Original
    'dQw4w9WgXcQ', // Rickroll
    '3JZ_D3ELwOQ', // Another popular video
    'dXAzKIeYwA0', // Classic
    '8Y0XW3-s6Ac', // Another fun one
    'Li4j82QbBvk'
  ];

  // Game state variables
  let currentDeathVideoId = '';
  let player;
  let playerReady = false;
  let gridSize = 32;
  let level = 1;
  let score = 0;
  let tileSize = canvas.width / gridSize;
  let snake, direction, size, food, enemies, bullets;
  let evolving = false;
  let gameRunning = true;

  // --------- Initialize YouTube API ---------
  window.onYouTubeIframeAPIReady = function() {
    currentDeathVideoId = deathVideos[randInt(0, deathVideos.length - 1)];
    player = new YT.Player('player', {
      height: '100%',
      width: '100%',
      videoId: currentDeathVideoId,
      playerVars: {
        autoplay: 1,
        controls: 1,
        modestbranding: 1,
        rel: 0,
        showinfo: 0,
        fs: 1,
        mute: 0,
        enablejsapi: 1,
        start: 0
      },
      events: {
        'onReady': onPlayerReady,
        'onStateChange': onPlayerStateChange
      }
    });
  };

  function onPlayerReady(event) {
    playerReady = true;
    console.log('YouTube player ready');
  }

  function onPlayerStateChange(event) {
    console.log('Player state changed:', event.data);
    if (event.data === YT.PlayerState.ENDED) {
      hideDeathOverlay();
    }
  }
  
  function hideDeathOverlay() {
    // Stop the video when hiding overlay
    if (player && playerReady) {
      try {
        player.pauseVideo();
      } catch (error) {
        console.error('Error pausing video:', error);
      }
    }
    
    overlay.style.display = 'none';
    gameContainer.style.display = 'flex';
    skipBtn.style.display = 'none';

    // Reset to initial level
    level = 1;
    score = 0;
    gridSize = 32;
    tileSize = canvas.width / gridSize;
    levelDisplay.textContent = "LEVEL 1: MICRO WORLD";
    levelDisplay.style.color = '#0ff';
    gameRunning = true;

    resetGame();
  }

  // Skip button functionality
  skipBtn.addEventListener('click', hideDeathOverlay);

  // --------- Utility functions ---------
  function randInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function spawnFood() {
    let attempts = 0;
    while (attempts < 100) {
      const pos = {x: randInt(0, gridSize - 1), y: randInt(0, gridSize - 1)};
      if (!isOccupied(pos)) return pos;
      attempts++;
    }
    // Fallback: return any position
    return {x: randInt(0, gridSize - 1), y: randInt(0, gridSize - 1)};
  }

  function isOccupied(pos) {
    if (snake && snake.some(s => s.x === pos.x && s.y === pos.y)) return true;
    if (enemies && enemies.some(e => {
      if (level === 1) {
        return e.x === pos.x && (e.y === pos.y || e.y + 1 === pos.y);
      } else {
        return Math.abs(e.x - pos.x) <= 1 && Math.abs(e.y - pos.y) <= 1;
      }
    })) return true;
    return false;
  }

  function updateScore() {
    scoreDisplay.textContent = `Score: ${score} | Size: ${size}`;
  }

  // --------- Enemy spawn functions ---------
  function spawnLevel1Enemy() {
    let attempts = 0;
    while (attempts < 50) {
      const side = Math.random() < 0.5 ? 0 : gridSize - 1;
      const y = randInt(0, gridSize - 3);
      const blocked = snake.some(s => s.x === side && (s.y === y || s.y === y + 1));
      if (!blocked) {
        return {
          type: 'poacher',
          baseX: side,
          x: side,
          y: y,
          dir: Math.random() < 0.5 ? 1 : -1,
          shootCooldown: randInt(100, 150),
          moveSideCooldown: randInt(100, 200),
          sideDir: 0,
          pauseTicks: 0,
          blocked: false
        };
      }
      attempts++;
    }
    // fallback
    return {
      type: 'poacher',
      baseX: 0,
      x: 0,
      y: 0,
      dir: 1,
      shootCooldown: randInt(100, 150),
      moveSideCooldown: randInt(100, 200),
      sideDir: 0,
      pauseTicks: 0,
      blocked: false
    };
  }

  function spawnLevel2Enemy() {
    const type = Math.random() < 0.5 ? 'jet' : 'tank';
    let attempts = 0;
    let x, y;
    
    // Find a spawn position away from snake
    do {
      x = randInt(2, gridSize - 3);
      y = randInt(2, gridSize - 3);
      attempts++;
    } while (attempts < 20 && snake.some(s => Math.abs(s.x - x) < 3 && Math.abs(s.y - y) < 3));

    if (type === 'jet') {
      return {
        type: 'jet',
        x: x,
        y: y,
        dx: (Math.random() < 0.5 ? -1 : 1) * 0.4,
        dy: (Math.random() < 0.5 ? -1 : 1) * 0.4,
        shootCooldown: randInt(70, 100),
        size: 2
      };
    } else {
      return {
        type: 'tank',
        x: x,
        y: y,
        dx: 0,
        dy: 0,
        shootCooldown: randInt(50, 80),
        moveCooldown: randInt(30, 60),
        size: 3,
        edible: false // Tanks are not edible
      };
    }
  }

  function spawnLevel3Enemy() {
    const types = ['laser_drone', 'bomber', 'destroyer'];
    const type = types[randInt(0, types.length - 1)];
    let attempts = 0;
    let x, y;
    
    // Find a spawn position away from snake
    do {
      x = randInt(3, gridSize - 4);
      y = randInt(3, gridSize - 4);
      attempts++;
    } while (attempts < 20 && snake.some(s => Math.abs(s.x - x) < 4 && Math.abs(s.y - y) < 4));

    if (type === 'laser_drone') {
      return {
        type: 'laser_drone',
        x: x,
        y: y,
        dx: (Math.random() < 0.5 ? -1 : 1) * (0.2 + level * 0.05),
        dy: (Math.random() < 0.5 ? -1 : 1) * (0.2 + level * 0.05),
        shootCooldown: Math.max(20, 70 - level * 5),
        laserCharging: false,
        laserCharge: 0,
        size: 1.5
      };
    } else if (type === 'bomber') {
      return {
        type: 'bomber',
        x: x,
        y: y,
        dx: (Math.random() < 0.5 ? -1 : 1) * (0.15 + level * 0.03),
        dy: (Math.random() < 0.5 ? -1 : 1) * (0.15 + level * 0.03),
        shootCooldown: Math.max(60, 180 - level * 10),
        size: 2.5
      };
    } else {
      return {
        type: 'destroyer',
        x: x,
        y: y,
        dx: 0,
        dy: 0,
        shootCooldown: Math.max(15, 50 - level * 3),
        moveCooldown: randInt(60, 100),
        size: 4,
        health: 3
      };
    }
  }

  function spawnLevel4PlusEnemy() {
    const types = ['phantom', 'singularity', 'chaos_lord', 'void_spawn'];
    const type = types[randInt(0, types.length - 1)];
    let attempts = 0;
    let x, y;
    
    // Find a spawn position away from snake
    do {
      x = randInt(2, gridSize - 3);
      y = randInt(2, gridSize - 3);
      attempts++;
    } while (attempts < 20 && snake.some(s => Math.abs(s.x - x) < 5 && Math.abs(s.y - y) < 5));

    if (type === 'phantom') {
      return {
        type: 'phantom',
        x: x,
        y: y,
        dx: (Math.random() - 0.5) * 0.8,
        dy: (Math.random() - 0.5) * 0.8,
        shootCooldown: randInt(40, 80),
        phase: 0,
        phaseTime: 0,
        size: 2
      };
    } else if (type === 'singularity') {
      return {
        type: 'singularity',
        x: x,
        y: y,
        dx: 0,
        dy: 0,
        shootCooldown: randInt(30, 60),
        pullRadius: 8,
        size: 3
      };
    } else if (type === 'chaos_lord') {
      return {
        type: 'chaos_lord',
        x: x,
        y: y,
        dx: 0,
        dy: 0,
        shootCooldown: randInt(20, 40),
        ability: 0,
        abilityCooldown: randInt(200, 300),
        size: 4,
        health: level
      };
    } else {
      return {
        type: 'void_spawn',
        x: x,
        y: y,
        dx: (Math.random() - 0.5) * 1.2,
        dy: (Math.random() - 0.5) * 1.2,
        shootCooldown: randInt(15, 30),
        splitTime: randInt(300, 500),
        size: 1.5
      };
    }
  }

  // --------- Game reset ---------
  function resetGame() {
    const centerX = Math.floor(gridSize / 2);
    const centerY = Math.floor(gridSize / 2);
    snake = [{x: centerX, y: centerY}];
    direction = {x: 1, y: 0};
    size = 3;
    food = spawnFood();
    enemies = [];
    bullets = [];
    updateScore();
    
    const enemyCount = level === 1 ? 2 : (level === 2 ? 4 : Math.min(8, 5 + level - 3));
    for (let i = 0; i < enemyCount; i++) {
      if (level === 1) {
        enemies.push(spawnLevel1Enemy());
      } else if (level === 2) {
        enemies.push(spawnLevel2Enemy());
      } else if (level === 3) {
        enemies.push(spawnLevel3Enemy());
      } else {
        // Level 4+ uses new enemy types mixed with level 3
        if (Math.random() < 0.6) {
          enemies.push(spawnLevel4PlusEnemy());
        } else {
          enemies.push(spawnLevel3Enemy());
        }
      }
    }
  }

  // --------- Level progression ---------
  function evolveToNextLevel() {
    if (evolving) return;
    evolving = true;
    
    // Flash effect
    document.body.style.filter = 'brightness(300%) hue-rotate(90deg)';
    setTimeout(() => {
      document.body.style.filter = '';
      evolving = false;
    }, 2000);
    
    level++;
    score += 1000; // Bonus for reaching new level
    
    if (level === 2) {
      levelDisplay.textContent = "LEVEL 2: MACRO WARFARE!";
      levelDisplay.style.color = '#ff0';
    } else if (level === 3) {
      levelDisplay.textContent = "LEVEL 3: COSMIC DOMINATION!";
      levelDisplay.style.color = '#f0f';
    } else if (level === 4) {
      levelDisplay.textContent = "LEVEL 4: DIMENSIONAL CHAOS!";
      levelDisplay.style.color = '#0f8';
    } else if (level === 5) {
      levelDisplay.textContent = "LEVEL 5: QUANTUM NIGHTMARE!";
      levelDisplay.style.color = '#f80';
    } else if (level === 6) {
      levelDisplay.textContent = "LEVEL 6: REALITY BREACH!";
      levelDisplay.style.color = '#8f0';
    } else if (level === 7) {
      levelDisplay.textContent = "LEVEL 7: VOID WALKER!";
      levelDisplay.style.color = '#f08';
    } else if (level === 8) {
      levelDisplay.textContent = "LEVEL 8: TIME DESTROYER!";
      levelDisplay.style.color = '#08f';
    } else if (level === 9) {
      levelDisplay.textContent = "LEVEL 9: UNIVERSE EATER!";
      levelDisplay.style.color = '#fff';
    } else if (level === 10) {
      levelDisplay.textContent = "LEVEL 10: OMNIPOTENT GOD!";
      levelDisplay.style.color = '#ffd700';
    } else {
      levelDisplay.textContent = `LEVEL ${level}: BEYOND INFINITY!`;
      levelDisplay.style.color = `hsl(${(level * 37) % 360}, 100%, 70%)`;
    }
    
    resetGame();
  }

  // --------- Drawing helper functions ---------
  function drawRect(x, y, color, w=1, h=1) {
    ctx.fillStyle = color;
    ctx.fillRect(x * tileSize, y * tileSize, tileSize * w, tileSize * h);
  }

  function drawCircle(x, y, r, c) {
    ctx.fillStyle = c;
    ctx.beginPath();
    ctx.arc((x + 0.5) * tileSize, (y + 0.5) * tileSize, r * tileSize, 0, Math.PI * 2);
    ctx.fill();
  }

  // --------- Game update ---------
  function update() {
    if (!gameRunning || evolving || !snake || !enemies || !bullets) return;

    const head = {
      x: (snake[0].x + direction.x + gridSize) % gridSize,
      y: (snake[0].y + direction.y + gridSize) % gridSize
    };
    snake.unshift(head);

    // Check food collision
    if (food && head.x === food.x && head.y === food.y) {
      size++;
      score += 10;
      food = spawnFood();
      updateScore();
      
      // Progressive size requirements for more levels
      let sizeRequirement;
      if (level === 1) sizeRequirement = 30;
      else if (level === 2) sizeRequirement = 50;
      else if (level === 3) sizeRequirement = 70;
      else if (level === 4) sizeRequirement = 90;
      else if (level === 5) sizeRequirement = 110;
      else sizeRequirement = 110 + (level - 5) * 20; // For levels 6+
      
      if (size >= sizeRequirement) {
        evolveToNextLevel();
        return;
      }
    } else {
      while (snake.length > size) snake.pop();
    }

    // Check collision with enemies
    for (let i = enemies.length - 1; i >= 0; i--) {
      const e = enemies[i];
      let collision = false;
      
      if (level === 1) {
        collision = head.x === e.x && (head.y === e.y || head.y === e.y + 1);
        if (collision) {
          size += 2;
          score += 50;
          enemies.splice(i, 1);
          enemies.push(spawnLevel1Enemy());
          updateScore();
        }
      } else if (level === 2) {
        // Level 2: jets are edible, tanks damage
        if (e.edible) {
          collision = Math.abs(head.x - e.x) < 1.0 && Math.abs(head.y - e.y) < 1.0;
          if (collision) {
            size += 3;
            score += 100;
            enemies.splice(i, 1);
            enemies.push(spawnLevel2Enemy());
            updateScore();
          }
        } else {
          collision = Math.abs(head.x - e.x) < 1.2 && Math.abs(head.y - e.y) < 1.2;
          if (collision) {
            size -= 2;
            updateScore();
            
            // Screen flash effect
            document.body.style.filter = 'brightness(50%) saturate(200%) hue-rotate(0deg)';
            setTimeout(() => {
              document.body.style.filter = '';
            }, 200);
          }
        }
      } else {
        // Level 3+: more dangerous enemies with bigger damage
        const damageRadius = e.type === 'destroyer' ? 2 : (e.type === 'chaos_lord' ? 2.5 : (e.type === 'singularity' ? 3 : 1.5));
        collision = Math.abs(head.x - e.x) < damageRadius && Math.abs(head.y - e.y) < damageRadius;
        if (collision) {
          let damage = 3; // Default damage
          if (e.type === 'destroyer') damage = 5;
          else if (e.type === 'bomber') damage = 4;
          else if (e.type === 'chaos_lord') damage = 6;
          else if (e.type === 'singularity') damage = 8;
          else if (e.type === 'phantom') damage = 4;
          else if (e.type === 'void_spawn') damage = 3;
          
          size -= damage;
          updateScore();
          
          // Stronger screen flash for level 3+
          document.body.style.filter = 'brightness(30%) saturate(300%) hue-rotate(180deg)';
          setTimeout(() => {
            document.body.style.filter = '';
          }, 300);
        }
      }
    }

    // Update enemies
    enemies.forEach(e => {
      if (level === 1 && e.type === 'poacher') {
        updatePoacher(e);
      } else if (level === 2) {
        updateLevel2Enemy(e);
      } else if (level === 3) {
        updateLevel3Enemy(e);
      } else {
        // Level 4+ enemies
        if (['phantom', 'singularity', 'chaos_lord', 'void_spawn'].includes(e.type)) {
          updateLevel4PlusEnemy(e);
        } else {
          updateLevel3Enemy(e); // Fallback for level 3 enemies in higher levels
        }
      }
    });

    // Update bullets
    for (let i = bullets.length - 1; i >= 0; i--) {
      const b = bullets[i];
      
      // Check despawn timer for all bullets
      if (b.despawnTime !== undefined) {
        b.despawnTime--;
        if (b.despawnTime <= 0) {
          bullets.splice(i, 1);
          continue;
        }
      }
      
      // Handle different bullet types
      if (b.type === 'homing') {
        // Homing bullets for level 2+
        b.homingTime--;
        
        if (b.homingTime > 0) {
          // Still homing
          const head = snake[0];
          const dx = head.x - b.x;
          const dy = head.y - b.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist > 0) {
            const homingStrength = 0.1;
            b.dx += (dx / dist) * homingStrength;
            b.dy += (dy / dist) * homingStrength;
            
            // Limit speed
            const speed = Math.sqrt(b.dx * b.dx + b.dy * b.dy);
            if (speed > 0.8) {
              b.dx = (b.dx / speed) * 0.8;
              b.dy = (b.dy / speed) * 0.8;
            }
          }
        }
        // After 3 seconds, bullets just fly straight
      } else if (b.type === 'laser') {
        // Lasers move very fast
        b.x += b.dx * 2;
        b.y += b.dy * 2;
      } else if (b.type === 'bomb') {
        // Bombs have gravity and explode
        b.dy += 0.02; // gravity
        b.life--;
        if (b.life <= 0) {
          // Create explosion
          createExplosion(b.x, b.y);
          bullets.splice(i, 1);
          continue;
        }
      }
      
      b.x += b.dx;
      b.y += b.dy;
      
      if (b.x < -5 || b.x >= gridSize + 5 || b.y < -5 || b.y >= gridSize + 5) {
        bullets.splice(i, 1);
        continue;
      }
      
      // Check collision with snake
      const hitRadius = b.type === 'bomb' ? 1.5 : (b.type === 'laser' ? 0.3 : 0.6);
      if (snake.some(s => Math.abs(s.x - b.x) < hitRadius && Math.abs(s.y - b.y) < hitRadius)) {
        const damage = b.type === 'bomb' ? 3 : (b.type === 'laser' ? 2 : 1);
        size -= damage;
        bullets.splice(i, 1);
        updateScore();
        
        // Visual feedback for different bullet types
        if (b.type === 'laser') {
          document.body.style.filter = 'brightness(200%) saturate(0%)';
          setTimeout(() => document.body.style.filter = '', 100);
        }
      }
    }

    // Check if SIZE goes negative (death condition)
    if (size < 0) {
      handleDeath();
      return;
    }

    // Check self-collision for death
    for (let i = 1; i < snake.length; i++) {
      if (snake[0].x === snake[i].x && snake[0].y === snake[i].y) {
        handleDeath();
        return;
      }
    }
  }

  function updatePoacher(e) {
    const touchingBody = snake.slice(1).some(s => s.x === e.x && (s.y === e.y || s.y === e.y + 1));
    
    if (touchingBody) {
      e.blocked = true;
    } else {
      e.blocked = false;
      
      if (e.pauseTicks > 0) {
        e.pauseTicks--;
        if (e.pauseTicks === 0) e.dir *= -1;
      } else {
        const nextY = e.y + e.dir;
        const wouldHitBody = snake.slice(1).some(s => s.x === e.x && (s.y === nextY || s.y === nextY + 1));
        
        if (!wouldHitBody && nextY >= 0 && nextY <= gridSize - 2) {
          e.y = nextY;
        }
        
        if (e.y <= 0 || e.y >= gridSize - 2) {
          e.pauseTicks = 30;
          e.y = Math.min(Math.max(e.y, 0), gridSize - 2);
        }
      }
      
      // Side movement
      e.moveSideCooldown--;
      if (e.moveSideCooldown <= 0) {
        e.sideDir = randInt(-1, 1);
        e.moveSideCooldown = randInt(100, 200);
      }
      
      let newX = e.x + e.sideDir;
      const sideWouldHitBody = snake.slice(1).some(s => s.x === newX && (s.y === e.y || s.y === e.y + 1));
      
      if (newX >= 0 && newX < gridSize && Math.abs(newX - e.baseX) <= 2 && !sideWouldHitBody) {
        e.x = newX;
      }
    }
    
    // Shooting
    e.shootCooldown--;
    if (e.shootCooldown <= 0 && !e.blocked) {
      const bulletX = e.baseX === 0 ? e.x + 1 : e.x - 1;
      if (bulletX >= 0 && bulletX < gridSize) {
        bullets.push({x: bulletX, y: e.y + 0.5, dx: e.baseX === 0 ? 1 : -1, dy: 0});
      }
      e.shootCooldown = randInt(120, 180);
    }
  }

  function updateLevel2Enemy(e) {
    if (e.type === 'jet') {
      e.x += e.dx;
      e.y += e.dy;
      
      if (e.x <= 0 || e.x >= gridSize - 1) {
        e.dx *= -1;
        e.x = Math.max(0, Math.min(gridSize - 1, e.x));
      }
      if (e.y <= 0 || e.y >= gridSize - 1) {
        e.dy *= -1;
        e.y = Math.max(0, Math.min(gridSize - 1, e.y));
      }
    } else if (e.type === 'tank') {
      e.moveCooldown--;
      if (e.moveCooldown <= 0) {
        e.dx = (randInt(-1, 1)) * 0.2;
        e.dy = (randInt(-1, 1)) * 0.2;
        e.moveCooldown = randInt(60, 120);
      }
      
      e.x += e.dx;
      e.y += e.dy;
      e.x = Math.max(0, Math.min(gridSize - 1, e.x));
      e.y = Math.max(0, Math.min(gridSize - 1, e.y));
    }
    
    // Shooting with homing bullets
    e.shootCooldown--;
    if (e.shootCooldown <= 0) {
      const head = snake[0];
      const dx = head.x - e.x;
      const dy = head.y - e.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist > 0 && dist < 15) {
        bullets.push({
          x: e.x, 
          y: e.y, 
          dx: (dx / dist) * 0.3, 
          dy: (dy / dist) * 0.3,
          type: 'homing',
          homingTime: 300 // 3 seconds at 100ms per frame
        });
      }
      
      e.shootCooldown = e.type === 'jet' ? randInt(80, 120) : randInt(60, 100);
    }
  }

  function updateLevel3Enemy(e) {
    const head = snake[0];
    
    if (e.type === 'laser_drone') {
      // Fast, erratic movement
      e.x += e.dx;
      e.y += e.dy;
      
      // Change direction randomly
      if (Math.random() < 0.05) {
        e.dx = (Math.random() - 0.5) * 0.4;
        e.dy = (Math.random() - 0.5) * 0.4;
      }
      
      // Bounce off walls
      if (e.x <= 0 || e.x >= gridSize - 1) e.dx *= -1;
      if (e.y <= 0 || e.y >= gridSize - 1) e.dy *= -1;
      e.x = Math.max(0, Math.min(gridSize - 1, e.x));
      e.y = Math.max(0, Math.min(gridSize - 1, e.y));
      
      // Laser charging and shooting
      e.shootCooldown--;
      if (e.shootCooldown <= 0 && !e.laserCharging) {
        e.laserCharging = true;
        e.laserCharge = 30; // Charge time
      }
      
      if (e.laserCharging) {
        e.laserCharge--;
        if (e.laserCharge <= 0) {
          // Fire thin laser beam
          const dx = head.x - e.x;
          const dy = head.y - e.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist > 0) {
            bullets.push({
              x: e.x,
              y: e.y,
              dx: (dx / dist) * 0.8,
              dy: (dy / dist) * 0.8,
              type: 'laser',
              despawnTime: 200 // 2 seconds
            });
          }
          
          e.laserCharging = false;
          e.shootCooldown = randInt(60, 100);
        }
      }
      
    } else if (e.type === 'bomber') {
      // Slow, steady movement
      e.x += e.dx;
      e.y += e.dy;
      
      // Bounce off walls
      if (e.x <= 1 || e.x >= gridSize - 2) e.dx *= -1;
      if (e.y <= 1 || e.y >= gridSize - 2) e.dy *= -1;
      e.x = Math.max(1, Math.min(gridSize - 2, e.x));
      e.y = Math.max(1, Math.min(gridSize - 2, e.y));
      
      // Drop bombs
      e.shootCooldown--;
      if (e.shootCooldown <= 0) {
        bullets.push({
          x: e.x,
          y: e.y,
          dx: (Math.random() - 0.5) * 0.2,
          dy: 0.1,
          type: 'bomb',
          life: 100,
          size: 4,
          despawnTime: 600 // 6 seconds
        });
        e.shootCooldown = randInt(100, 150);
      }
      
    } else if (e.type === 'destroyer') {
      // Heavy, slow but deadly
      e.moveCooldown--;
      if (e.moveCooldown <= 0) {
        // Move towards snake slowly
        const dx = head.x - e.x;
        const dy = head.y - e.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist > 0) {
          e.dx = (dx / dist) * 0.1;
          e.dy = (dy / dist) * 0.1;
        }
        e.moveCooldown = randInt(40, 80);
      }
      
      e.x += e.dx;
      e.y += e.dy;
      e.x = Math.max(2, Math.min(gridSize - 3, e.x));
      e.y = Math.max(2, Math.min(gridSize - 3, e.y));
      
      // Rapid fire spread shots
      e.shootCooldown--;
      if (e.shootCooldown <= 0) {
        // Fire spread of homing bullets
        for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 4) {
          bullets.push({
            x: e.x,
            y: e.y,
            dx: Math.cos(angle) * 0.25,
            dy: Math.sin(angle) * 0.25,
            type: 'homing',
            homingTime: 300, // 3 seconds
            despawnTime: 800 // 8 seconds total
          });
        }
        e.shootCooldown = randInt(80, 120);
      }
    }
  }

  function updateLevel4PlusEnemy(e) {
    const head = snake[0];
    
    if (e.type === 'phantom') {
      // Phases in and out of reality
      e.phaseTime++;
      if (e.phaseTime > 100) {
        e.phase = (e.phase + 1) % 3; // 0=solid, 1=fading, 2=ghost
        e.phaseTime = 0;
      }
      
      // Movement
      e.x += e.dx;
      e.y += e.dy;
      
      // Can pass through walls when ghosted
      if (e.phase !== 2) {
        if (e.x <= 0 || e.x >= gridSize - 1) e.dx *= -1;
        if (e.y <= 0 || e.y >= gridSize - 1) e.dy *= -1;
        e.x = Math.max(0, Math.min(gridSize - 1, e.x));
        e.y = Math.max(0, Math.min(gridSize - 1, e.y));
      } else {
        // Wrap around when ghosted
        e.x = (e.x + gridSize) % gridSize;
        e.y = (e.y + gridSize) % gridSize;
      }
      
      // Shooting
      e.shootCooldown--;
      if (e.shootCooldown <= 0 && e.phase === 0) {
        const dx = head.x - e.x;
        const dy = head.y - e.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist > 0) {
          bullets.push({
            x: e.x,
            y: e.y,
            dx: (dx / dist) * 0.6,
            dy: (dy / dist) * 0.6,
            type: 'phantom_bolt',
            despawnTime: 300
          });
        }
        e.shootCooldown = randInt(60, 100);
      }
      
    } else if (e.type === 'singularity') {
      // Pulls snake towards it
      const dx = head.x - e.x;
      const dy = head.y - e.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist < e.pullRadius && dist > 0) {
        // Apply gravitational pull to snake
        const pullStrength = (e.pullRadius - dist) / e.pullRadius * 0.1;
        snake[0].x -= (dx / dist) * pullStrength;
        snake[0].y -= (dy / dist) * pullStrength;
      }
      
      // Shooting black holes
      e.shootCooldown--;
      if (e.shootCooldown <= 0) {
        bullets.push({
          x: e.x,
          y: e.y,
          dx: (Math.random() - 0.5) * 0.4,
          dy: (Math.random() - 0.5) * 0.4,
          type: 'black_hole',
          life: 200,
          despawnTime: 400
        });
        e.shootCooldown = randInt(80, 120);
      }
      
    } else if (e.type === 'chaos_lord') {
      // Boss-like enemy with multiple abilities
      e.moveCooldown--;
      if (e.moveCooldown <= 0) {
        const dx = head.x - e.x;
        const dy = head.y - e.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist > 0) {
          e.dx = (dx / dist) * 0.15;
          e.dy = (dy / dist) * 0.15;
        }
        e.moveCooldown = randInt(30, 60);
      }
      
      e.x += e.dx;
      e.y += e.dy;
      e.x = Math.max(1, Math.min(gridSize - 2, e.x));
      e.y = Math.max(1, Math.min(gridSize - 2, e.y));
      
      // Regular shooting
      e.shootCooldown--;
      if (e.shootCooldown <= 0) {
        for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 6) {
          bullets.push({
            x: e.x,
            y: e.y,
            dx: Math.cos(angle) * 0.4,
            dy: Math.sin(angle) * 0.4,
            type: 'chaos_bolt',
            despawnTime: 400
          });
        }
        e.shootCooldown = randInt(40, 80);
      }
      
      // Special abilities
      e.abilityCooldown--;
      if (e.abilityCooldown <= 0) {
        // Summon void spawns
        for (let i = 0; i < 2; i++) {
          enemies.push(spawnLevel4PlusEnemy());
        }
        e.abilityCooldown = randInt(400, 600);
      }
      
    } else if (e.type === 'void_spawn') {
      // Fast, aggressive, splits when destroyed
      e.x += e.dx;
      e.y += e.dy;
      
      // Aggressive homing
      const dx = head.x - e.x;
      const dy = head.y - e.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist > 0 && dist < 10) {
        e.dx += (dx / dist) * 0.05;
        e.dy += (dy / dist) * 0.05;
      }
      
      // Bounce off walls
      if (e.x <= 0 || e.x >= gridSize - 1) e.dx *= -1;
      if (e.y <= 0 || e.y >= gridSize - 1) e.dy *= -1;
      e.x = Math.max(0, Math.min(gridSize - 1, e.x));
      e.y = Math.max(0, Math.min(gridSize - 1, e.y));
      
      // Rapid fire
      e.shootCooldown--;
      if (e.shootCooldown <= 0) {
        if (dist > 0) {
          bullets.push({
            x: e.x,
            y: e.y,
            dx: (dx / dist) * 0.8,
            dy: (dy / dist) * 0.8,
            type: 'void_shard',
            despawnTime: 200
          });
        }
        e.shootCooldown = randInt(20, 40);
      }
    }
  }

  // --------- Drawing ---------
  function draw() {
    // Background
    ctx.fillStyle = level === 1 ? '#000' : (level === 2 ? '#001122' : '#220011');
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw food
    if (food) {
      const foodColor = level === 1 ? '#0f0' : (level === 2 ? '#ff0' : '#f0f');
      drawRect(food.x, food.y, foodColor);
      
      // Pulsing effect for food
      const pulse = Math.sin(Date.now() * 0.01) * 0.2 + 0.8;
      ctx.globalAlpha = pulse;
      drawRect(food.x, food.y, foodColor);
      ctx.globalAlpha = 1;
    }

    // Draw snake
    snake.forEach((s, i) => {
      const col = i === 0 ? 
        (level === 1 ? '#0ff' : (level === 2 ? '#ff0' : '#f0f')) : 
        (level === 1 ? '#09f' : (level === 2 ? '#fa0' : '#f09'));
      drawRect(s.x, s.y, col);
    });

    // Draw enemies
    enemies.forEach(e => {
      if (level === 1) {
        drawRect(e.x, e.y, '#ff6600');
        drawRect(e.x, e.y + 1, '#ff6600');
        // Gun barrel
        if (e.baseX === 0 && e.x + 1 < gridSize) {
          drawRect(e.x + 1, e.y, '#666');
        }
        if (e.baseX === gridSize - 1 && e.x - 1 >= 0) {
          drawRect(e.x - 1, e.y, '#666');
        }
      } else if (level === 2) {
        if (e.type === 'jet') {
          // Jets are edible - green tint
          drawCircle(e.x, e.y, 0.8, '#448844');
          drawCircle(e.x, e.y, 0.4, '#66aa66');
        } else if (e.type === 'tank') {
          // Tanks are dangerous - red tint
          drawRect(Math.floor(e.x), Math.floor(e.y), '#664444', 1, 1);
          drawCircle(e.x, e.y, 0.3, '#996666');
        }
      } else {
        // Level 3+ enemies
        if (e.type === 'laser_drone') {
          const color = e.laserCharging ? '#ff4444' : '#4444ff';
          drawCircle(e.x, e.y, 0.7, color);
          drawCircle(e.x, e.y, 0.3, '#fff');
          
          // Show charging effect
          if (e.laserCharging) {
            const chargeProgress = (30 - e.laserCharge) / 30;
            drawCircle(e.x, e.y, 1.2 * chargeProgress, 'rgba(255, 0, 0, 0.3)');
          }
        } else if (e.type === 'bomber') {
          drawRect(Math.floor(e.x - 1), Math.floor(e.y - 1), '#444', 2, 2);
          drawCircle(e.x, e.y, 0.8, '#666');
          drawCircle(e.x, e.y, 0.4, '#888');
        } else if (e.type === 'destroyer') {
          drawRect(Math.floor(e.x - 1.5), Math.floor(e.y - 1.5), '#222', 3, 3);
          drawCircle(e.x, e.y, 1.2, '#444');
          drawCircle(e.x, e.y, 0.8, '#666');
          drawCircle(e.x, e.y, 0.4, '#888');
        }
      }
    });

    // Draw bullets
    bullets.forEach(b => {
      if (b.type === 'homing') {
        // Red homing bullets - change color when no longer homing
        const isHoming = b.homingTime > 0;
        const color = isHoming ? '#ff2222' : '#ff6666';
        const innerColor = isHoming ? '#ffaaaa' : '#ffcccc';
        drawCircle(b.x, b.y, 0.3, color);
        drawCircle(b.x, b.y, 0.15, innerColor);
      } else if (b.type === 'laser') {
        // Thin white laser beams
        drawCircle(b.x, b.y, 0.1, '#ffffff');
        drawCircle(b.x, b.y, 0.05, '#aaffff');
      } else if (b.type === 'bomb') {
        // Large dark bombs
        const size = Math.min(2, b.life / 25);
        drawRect(Math.floor(b.x - size/2), Math.floor(b.y - size/2), '#331100', size, size);
        drawCircle(b.x, b.y, size * 0.3, '#664422');
      } else if (b.type === 'explosion') {
        // Explosion particles
        const intensity = b.life / 20;
        drawCircle(b.x, b.y, 0.2 * intensity, `rgba(255, ${Math.floor(100 + 155 * intensity)}, 0, ${intensity})`);
      } else {
        // Default bullets
        if (level === 1) {
          drawRect(Math.floor(b.x), Math.floor(b.y), '#ff4444');
        } else {
          drawCircle(b.x, b.y, 0.2, '#ff4444');
        }
      }
    });
  }

  // --------- Main game loop ---------
  function gameLoop() {
    update();
    draw();
  }

  // --------- Controls ---------
  document.querySelectorAll('.btn').forEach(btn => {
    btn.addEventListener('touchstart', e => {
      e.preventDefault();
      handleDirection(btn.getAttribute('data-dir'));
    });
    btn.addEventListener('click', () => handleDirection(btn.getAttribute('data-dir')));
  });

  window.addEventListener('keydown', e => {
    e.preventDefault();
    if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') handleDirection('up');
    if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') handleDirection('down');
    if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') handleDirection('left');
    if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') handleDirection('right');
  });

  function handleDirection(dir) {
    if (!gameRunning) return;
    
    if (dir === 'up' && direction.y === 0) direction = {x: 0, y: -1};
    if (dir === 'down' && direction.y === 0) direction = {x: 0, y: 1};
    if (dir === 'left' && direction.x === 0) direction = {x: -1, y: 0};
    if (dir === 'right' && direction.x === 0) direction = {x: 1, y: 0};
  }

  // --------- Death handling ---------
  function handleDeath() {
    gameRunning = false;
    currentDeathVideoId = deathVideos[randInt(0, deathVideos.length - 1)];
    console.log('Death triggered, loading video:', currentDeathVideoId);
    
    overlay.style.display = 'flex';
    gameContainer.style.display = 'none';
    
    // Show skip button after 5 seconds
    setTimeout(() => {
      skipBtn.style.display = 'block';
      skipBtn.textContent = 'Skip Ad';
    }, 5000);
    
    if (player && playerReady) {
      try {
        player.loadVideoById({
          videoId: currentDeathVideoId,
          startSeconds: 0
        });
        
        setTimeout(() => {
          if (player.playVideo) {
            player.playVideo();
          }
        }, 1000);
      } catch (error) {
        console.error('Error loading video:', error);
        setTimeout(hideDeathOverlay, 3000);
      }
    } else {
      console.log('Player not ready, showing fallback');
      setTimeout(hideDeathOverlay, 5000);
    }
  }

  // --------- Initialize game ---------
  resetGame();
  const gameInterval = setInterval(gameLoop, 100);

})();
</script>
</body>
</html>
